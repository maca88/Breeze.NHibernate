using System;
using System.Linq.Expressions;
using Breeze.NHibernate.Extensions;
using Breeze.NHibernate.Metadata;

namespace Breeze.NHibernate.Configuration
{
    /// <inheritdoc />
    internal class ModelConfigurator : IModelConfigurator
    {
        public ModelConfigurator(ModelConfiguration configuration)
        {
            Configuration = configuration;
        }

        internal ModelConfiguration Configuration { get; }

        /// <inheritdoc />
        public IModelConfigurator ResourceName(string resourceName)
        {
            Configuration.ResourceName = resourceName;
            return this;
        }

        /// <inheritdoc />
        public IModelConfigurator RefreshAfterSave(bool value)
        {
            Configuration.RefreshAfterSave = value;
            return this;
        }

        /// <inheritdoc />
        public IModelConfigurator RefreshAfterUpdate(bool value)
        {
            Configuration.RefreshAfterUpdate = value;
            return this;
        }

        /// <inheritdoc />
        public IModelConfigurator BatchFetchSize(int value)
        {
            Configuration.BatchFetchSize = value;
            return this;
        }

        /// <inheritdoc />
        public IModelConfigurator AutoGeneratedKeyType(AutoGeneratedKeyType value)
        {
            Configuration.AutoGeneratedKeyType = value;
            return this;
        }

        /// <inheritdoc />
        public IModelConfigurator Custom(object value)
        {
            Configuration.Custom = value;
            return this;
        }

        /// <inheritdoc />
        public IModelConfigurator ForMember(
            string memberName,
            Action<IMemberConfigurator> action)
        {
            var configuration = Configuration.GetMember(memberName);
            if (configuration == null)
            {
                throw new InvalidOperationException(
                    $"Type '{Configuration.ModelType}' does not contain a member with name '{memberName}' or it is not configurable. " +
                    $"Supply a custom {nameof(ITypeMembersProvider)} implementation in case the member should be configurable.");
            }

            action?.Invoke(new MemberConfigurator(configuration));

            return this;
        }

        /// <inheritdoc />
        public IModelConfigurator ForSyntheticMember<TMember>(string memberName, Action<ISyntheticMemberConfigurator> action)
        {
            var configuration = Configuration.GetOrAdd(memberName, n =>
                new SyntheticMemberConfiguration(
                    memberName,
                    typeof(TMember),
                    Configuration.ModelType));
            action?.Invoke(new SyntheticMemberConfigurator(configuration));

            return this;
        }

        /// <inheritdoc />
        public IModelConfigurator AddSyntheticMember<TMember>(
            string memberName,
            SerializeSyntheticMemberDelegate serializeFunction,
            Action<ISyntheticMemberConfigurator> action)
        {
            var configuration = Configuration.GetOrAdd(memberName, n =>
                new SyntheticMemberConfiguration(
                    memberName,
                    typeof(TMember),
                    Configuration.ModelType,
                    serializeFunction));
            action?.Invoke(new SyntheticMemberConfigurator(configuration));

            return this;
        }
    }

    internal class ModelConfigurator<TModel> : IModelConfigurator<TModel>
    {
        public ModelConfigurator(ModelConfiguration configuration)
        {
            Configuration = configuration;
        }

        internal ModelConfiguration Configuration { get; }

        /// <inheritdoc />
        public IModelConfigurator<TModel> ResourceName(string resourceName)
        {
            Configuration.ResourceName = resourceName;
            return this;
        }

        /// <inheritdoc />
        public IModelConfigurator<TModel> RefreshAfterSave(bool value)
        {
            Configuration.RefreshAfterSave = value;
            return this;
        }

        /// <inheritdoc />
        public IModelConfigurator<TModel> RefreshAfterUpdate(bool value)
        {
            Configuration.RefreshAfterUpdate = value;
            return this;
        }

        /// <inheritdoc />
        public IModelConfigurator<TModel> BatchFetchSize(int value)
        {
            Configuration.BatchFetchSize = value;
            return this;
        }

        /// <inheritdoc />
        public IModelConfigurator<TModel> AutoGeneratedKeyType(AutoGeneratedKeyType value)
        {
            Configuration.AutoGeneratedKeyType = value;
            return this;
        }

        /// <inheritdoc />
        public IModelConfigurator<TModel> Custom(object value)
        {
            Configuration.Custom = value;
            return this;
        }

        /// <inheritdoc />
        public IModelConfigurator<TModel> ForMember<TMember>(
            Expression<Func<TModel, TMember>> memberExpression,
            Action<IMemberConfigurator<TModel, TMember>> action)
        {
            var member = memberExpression.GetMemberInfo();
            var configuration = Configuration.GetMember(member.Name);
            if (configuration == null)
            {
                throw new InvalidOperationException(
                    $"Type '{Configuration.ModelType}' does not contain a member with name '{member.Name}' or it is not configurable. " +
                    $"Supply a custom {nameof(ITypeMembersProvider)} implementation in case the member should be configurable.");
            }

            action?.Invoke(new MemberConfigurator<TModel, TMember>(configuration));

            return this;
        }

        /// <inheritdoc />
        public IModelConfigurator<TModel> ForSyntheticMember<TMember>(string memberName, Action<ISyntheticMemberConfigurator<TModel, TMember>> action)
        {
            var configuration = Configuration.GetOrAdd(memberName, n =>
                new SyntheticMemberConfiguration(
                    memberName,
                    typeof(TMember),
                    typeof(TModel)));
            action?.Invoke(new SyntheticMemberConfigurator<TModel, TMember>(configuration));

            return this;
        }

        /// <inheritdoc />
        public IModelConfigurator<TModel> AddSyntheticMember<TMember>(
            string memberName,
            Func<TModel, TMember> serializeFunction,
            Action<ISyntheticMemberConfigurator<TModel, TMember>> action)
        {
            if (serializeFunction == null)
            {
                throw new ArgumentNullException(nameof(serializeFunction));
            }

            if (Configuration.SyntheticMembers.ContainsKey(memberName))
            {
                throw new InvalidOperationException($"Synthetic member {memberName} was already added, use ForSyntheticMember instead.");
            }

            var configuration = Configuration.GetOrAdd(memberName, n =>
                new SyntheticMemberConfiguration(
                    memberName,
                    typeof(TMember),
                    typeof(TModel),
                    (model, name) => serializeFunction((TModel) model)));
            action?.Invoke(new SyntheticMemberConfigurator<TModel, TMember>(configuration));

            return this;
        }
    }
}
