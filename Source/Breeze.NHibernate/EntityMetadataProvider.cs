using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using Breeze.NHibernate.Extensions;
using Breeze.NHibernate.Internal;
using Breeze.NHibernate.Metadata;
using Breeze.NHibernate.Serialization;
using NHibernate.Dialect;
using NHibernate.Engine;
using NHibernate.Id;
using NHibernate.Persister.Collection;
using NHibernate.Persister.Entity;
using NHibernate.Type;
using NHibernate.Util;
using EntityType = NHibernate.Type.EntityType;

namespace Breeze.NHibernate
{
    /// <inheritdoc />
    public class EntityMetadataProvider : IEntityMetadataProvider
    {
        private static readonly MethodInfo AddToParentMethod;
        private static readonly MethodInfo RemoveFromParentMethod;
        private static readonly IReadOnlyDictionary<string, Func<object, object>> EmptyDictionary = new Dictionary<string, Func<object, object>>();

        static EntityMetadataProvider()
        {
            AddToParentMethod = ReflectHelper.GetMethodDefinition(() => CreateAddToParentFunction<object>(default, default));
            RemoveFromParentMethod = ReflectHelper.GetMethodDefinition(() => CreateRemoveFromParentFunction<object>(default, default));
        }

        private readonly INHibernateClassMetadataProvider _nhClassMetadataProvider;
        private readonly ISyntheticPropertyNameConvention _syntheticPropertyNameConvention;
        private readonly IEntityBatchFetcherFactory _entityBatchFetcherFactory;
        private readonly ConcurrentDictionary<Type, EntityMetadata> _cachedMetadata = new ConcurrentDictionary<Type, EntityMetadata>();

        public EntityMetadataProvider(
            INHibernateClassMetadataProvider nhClassMetadataProvider,
            ISyntheticPropertyNameConvention syntheticPropertyNameConvention,
            IEntityBatchFetcherFactory entityBatchFetcherFactory)
        {
            _nhClassMetadataProvider = nhClassMetadataProvider;
            _syntheticPropertyNameConvention = syntheticPropertyNameConvention;
            _entityBatchFetcherFactory = entityBatchFetcherFactory;
        }

        /// <inheritdoc />
        public EntityMetadata GetMetadata(Type entityType)
        {
            return _cachedMetadata.GetOrAdd(entityType, CreateMetadata);
        }

        /// <inheritdoc />
        public bool IsEntityType(Type type)
        {
            return _nhClassMetadataProvider.Get(type.FullName) != null;
        }

        private EntityMetadata CreateMetadata(Type entityType)
        {
            var persister = GetEntityPersister(entityType.FullName, true);
            GetPkPropertyNames(persister, out var pkPropertyNames, out var pkPropertyTypes, out var pkPropertyGetters, out var hasCompositeKey);
            var associations = new Dictionary<string, Association>();
            var foreignKeyAssociations = new Dictionary<string, EntityAssociation>();
            var derivedPropertyNames = new HashSet<string>(GetDerivedPropertyNames(persister));
            var syntheticProperties = GetSyntheticProperties(
                    persister,
                    derivedPropertyNames,
                    associations,
                    foreignKeyAssociations)
                .ToDictionary(o => o.Name);
            var foreignPropertyNames = new HashSet<string>(foreignKeyAssociations.Keys); 
            return new EntityMetadata(
                persister,
                CreateEntityCreator(entityType),
                _entityBatchFetcherFactory.Create(persister),
                persister.MappedClass,
                persister.EntityMetamodel.SuperclassType,
                GetAutoGeneratedKeyType(persister),
                persister.IsVersioned ? persister.PropertyNames[persister.VersionProperty] : null,
                persister.IsVersioned ? persister.PropertyTypes[persister.VersionProperty].ReturnedClass : null,
                hasCompositeKey,
                syntheticProperties,
                GetDerivedTypes(persister).ToList(),
                derivedPropertyNames,
                pkPropertyNames.ToList(),
                pkPropertyGetters.ToList(),
                pkPropertyTypes.Select(o => o.ReturnedClass).ToList(),
                pkPropertyTypes.Select(BreezeHelper.GetDataType).ToList(),
                pkPropertyTypes.Select(t => BreezeHelper.GetTypeLength(t, persister.Factory)).ToList(),
                foreignPropertyNames,
                associations,
                foreignKeyAssociations,
                GetManyToOneIdentifierProperties(persister) ?? EmptyDictionary
            );
        }

        private IEnumerable<SyntheticForeignKeyProperty> GetSyntheticProperties(
            AbstractEntityPersister persister,
            HashSet<string> superPropertyNames,
            Dictionary<string, Association> associations,
            Dictionary<string, EntityAssociation> foreignKeyAssociations)
        {
            var enumerable = GetSyntheticProperties(
                persister,
                persister.PropertyNames,
                persister.PropertyTypes,
                persister.PropertyNullability,
                persister.PropertyCascadeStyles,
                superPropertyNames,
                associations,
                foreignKeyAssociations,
                false,
                persister.GetPropertyColumnNames,
                i => GetPropertyValueFunction(persister, i));

            // Support only for embedded component type
            if (!(persister.IdentifierType is ComponentType componentType) || !componentType.IsEmbedded)
            {
                return enumerable;
            }

            var allColumnNames = persister.IdentifierColumnNames;
            return enumerable.Concat(GetSyntheticProperties(
                persister,
                componentType.PropertyNames,
                componentType.Subtypes,
                componentType.PropertyNullability,
                null,
                superPropertyNames,
                associations,
                foreignKeyAssociations,
                true,
                i => GetComponentPropertyColumnNames(persister.Factory, componentType, i, allColumnNames),
                i => GetPropertyValueFunction(componentType, i)));
        }

        private IEnumerable<SyntheticForeignKeyProperty> GetSyntheticProperties(
            AbstractEntityPersister persister,
            string[] propertyNames,
            IType[] propertyTypes,
            bool[] propertyNullability,
            CascadeStyle[] propertyCascadeStyles,
            HashSet<string> derivedPropertyNames,
            Dictionary<string, Association> associations,
            Dictionary<string, EntityAssociation> foreignKeyAssociations,
            bool identifier,
            Func<int, string[]> getColumnNamesFunc,
            Func<int, Func<object, object>> getPropertyValueFunc)
        {
            var dialect = persister.Factory.Dialect;
            GetPkPropertyNames(persister, out var pkPropertyNames, out _, out _, out _);
            // Create synthetic property for each entity association
            for (var i = 0; i < propertyNames.Length; i++)
            {
                if (!(propertyTypes[i] is IAssociationType associationType))
                {
                    continue;
                }

                var foreignKeyDirection = associationType.ForeignKeyDirection;
                var fkProperties = new List<string>();
                var joinable = associationType.GetAssociatedJoinable(persister.Factory);
                if (associationType is CollectionType collectionType)
                {
                    var collectionPersister = (IQueryableCollection) joinable;
                    if (!(collectionPersister.ElementPersister is AbstractEntityPersister elementPersister))
                    {
                        throw new NotSupportedException(
                            $"Element persister for collection {collectionPersister.Role} does not derive from AbstractEntityPersister");
                    }

                    var elementColumnProperties = GetColumnProperties(elementPersister, false);
                    var elementColumnEntities = GetColumnProperties(elementPersister, true);
                    var referencedColumns = collectionType.GetReferencedColumns(persister.Factory);
                    for (var j = 0; j < referencedColumns.Length; j++)
                    {
                        var column = referencedColumns[j];
                        var pkPropertyName = pkPropertyNames[j];
                        if (column == null)
                        {
                            continue; // Formula
                        }

                        column = dialect.UnQuote(column);
                        if (elementColumnProperties.TryGetValue(column, out var propertyName))
                        {
                            fkProperties.Add(propertyName);
                        }
                        else if (elementColumnEntities.TryGetValue(column, out propertyName))
                        {
                            // We will have to create a synthetic property
                            fkProperties.Add(_syntheticPropertyNameConvention.GetName(propertyName, pkPropertyName));
                        }
                    }

                    associations.Add(propertyNames[i], new Association(elementPersister.MappedClass, fkProperties, foreignKeyDirection, false));
                    continue;
                }

                if (!(associationType is EntityType entityType))
                {
                    continue;
                }

                // Handle ManyToOne/OneToOne associations
                var columnProperties = GetColumnProperties(persister, false);
                var relatedEntityPersister = GetEntityPersister(entityType.Name, true);
                var columnNames = getColumnNamesFunc(i);
                GetPkPropertyNames(
                    relatedEntityPersister,
                    out var relatedPkPropertyNames,
                    out var relatedPkPropertyTypes,
                    out var relatedPkPropertyGetters,
                    out var isComposite);
                for (var j = 0; j < columnNames.Length; j++)
                {
                    var columnName = columnNames[j];
                    var relatedPkPropertyName = relatedPkPropertyNames[j];
                    var relatedPkPropertyType = relatedPkPropertyTypes[j];
                    var getRelatedPkPropertyFunction = relatedPkPropertyGetters[j];
                    if (columnName == null)
                    {
                        continue; // Formula
                    }

                    if (columnProperties.TryGetValue(dialect.UnQuote(columnName), out var propertyName))
                    {
                        fkProperties.Add(propertyName);
                        continue; // A foreign key property is already declared
                    }

                    // We will have to create a synthetic property
                    propertyName = _syntheticPropertyNameConvention.GetName(propertyNames[i], relatedPkPropertyName);
                    fkProperties.Add(propertyName);

                    yield return new SyntheticForeignKeyProperty
                    {
                        Name = propertyName,
                        Derived = derivedPropertyNames.Contains(propertyNames[i]),
                        HasCompositeKey = isComposite,
                        EntityType = relatedEntityPersister.MappedClass,
                        AssociationPropertyName = propertyNames[i],
                        GetAssociationFunction = getPropertyValueFunc(i),
                        IsNullable = propertyNullability[i],
                        IsPartOfKey = identifier,
                        IdentifierPropertyName = relatedPkPropertyName,
                        GetIdentifierFunction = getRelatedPkPropertyFunction,
                        IdentifierType = relatedPkPropertyType.ReturnedClass,
                        IdentifierDataType = BreezeHelper.GetDataType(relatedPkPropertyType),
                        IdentifierLength = BreezeHelper.GetTypeLength(relatedPkPropertyType, relatedEntityPersister.Factory)
                    };
                }

                var inversePropertyIndex = GetInversePropertyIndex(
                    columnNames,
                    entityType,
                    persister,
                    relatedEntityPersister,
                    out var isChildAssociation,
                    out var isOneToOne);
                if (entityType.IsOneToOne) // In this case columnNames will be empty so fkProperties will not be populated
                {
                    if (persister.IdentifierGenerator is ForeignGenerator)
                    {
                        fkProperties.Add(persister.IdentifierPropertyName);
                    }
                    else if (relatedEntityPersister.IdentifierGenerator is ForeignGenerator)
                    {
                        fkProperties.Add(relatedEntityPersister.IdentifierPropertyName);
                    }
                    else if (inversePropertyIndex.HasValue && relatedEntityPersister.PropertyTypes[inversePropertyIndex.Value] is ManyToOneType)
                    {
                        // When one-to-one relation is associated with many-to-one NH does not contain a correct fk direction so we have to override it
                        foreignKeyDirection = ForeignKeyDirection.ForeignKeyToParent;
                        var columns = relatedEntityPersister.GetPropertyColumnNames(inversePropertyIndex.Value);
                        var relatedColumnProperties = GetColumnProperties(relatedEntityPersister, false);
                        var propertyName = relatedEntityPersister.PropertyNames[inversePropertyIndex.Value];
                        for (var j = 0; j < columns.Length; j++)
                        {
                            var column = columns[j];
                            if (column == null)
                            {
                                continue; // Formula
                            }

                            fkProperties.Add(relatedColumnProperties.TryGetValue(dialect.UnQuote(column), out var fkProperty)
                                    ? fkProperty
                                    : _syntheticPropertyNameConvention.GetName(propertyName, relatedPkPropertyNames[j]));
                        }
                    }
                }

                var association = new EntityAssociation(
                    relatedEntityPersister.MappedClass,
                    entityType.IsOneToOne,
                    fkProperties,
                    foreignKeyDirection,
                    relatedEntityPersister.IdentifierType,
                    isChildAssociation,
                    inversePropertyIndex.HasValue ? relatedEntityPersister.PropertyNames[inversePropertyIndex.Value] : null,
                    inversePropertyIndex.HasValue ? relatedEntityPersister.PropertyCascadeStyles[inversePropertyIndex.Value] : null,
                    propertyNames[i],
                    propertyCascadeStyles?[i] ?? CascadeStyle.None,
                    CreateAddToParentFunction(relatedEntityPersister, inversePropertyIndex, isOneToOne),
                    CreateRemoveToParentFunction(relatedEntityPersister, inversePropertyIndex, isOneToOne)
                );
                foreach (var fkProperty in fkProperties)
                {
                    foreignKeyAssociations.Add(fkProperty, association);
                }

                associations.Add(propertyNames[i], association);
            }
        }

        private AbstractEntityPersister GetEntityPersister(string entityName, bool throwOnNotFound)
        {
            var classMetadata = _nhClassMetadataProvider.Get(entityName);
            if (classMetadata is AbstractEntityPersister persister)
            {
                return persister;
            }

            if (throwOnNotFound)
            {
                throw new NotSupportedException(
                    "Class meta data that do not derive from AbstractEntityPersister is not supported. " +
                    $"MappedClass: {classMetadata?.MappedClass.ToString() ?? entityName}");
            }

            return null;
        }

        private static Func<object> CreateEntityCreator(Type type)
        {
            var ctor = ReflectHelper.GetDefaultConstructor(type);
            if (ctor == null)
            {
                return null; // Abstract class
            }

            return Expression.Lambda<Func<object>>(Expression.Convert(Expression.New(ctor), typeof(object))).Compile();
        }

        private static Action<object, object> CreateAddToParentFunction(
            AbstractEntityPersister parentPersister,
            int? inversePropertyIndex,
            bool isOneToOne)
        {
            if (!inversePropertyIndex.HasValue)
            {
                return null;
            }

            if (isOneToOne)
            {
                return CreateSetParentFunction(parentPersister, inversePropertyIndex.Value);
            }

            // Get the element type from the collection in case it is a base class
            var type = (CollectionType)parentPersister.PropertyTypes[inversePropertyIndex.Value];
            if (!type.ReturnedClass.TryGetGenericType(typeof(ICollection<>), out var collectionType))
            {
                throw new NotSupportedException($"Mapped collection: {type.Role} is not supported.");
            }

            return (Action<object, object>)AddToParentMethod.MakeGenericMethod(collectionType.GenericTypeArguments[0])
                .Invoke(null, new object[] {parentPersister, inversePropertyIndex.Value});
        }

        private static Action<object, object> CreateRemoveToParentFunction(
            AbstractEntityPersister parentPersister,
            int? inversePropertyIndex,
            bool isOneToOne)
        {
            if (!inversePropertyIndex.HasValue)
            {
                return null;
            }

            if (isOneToOne)
            {
                return CreateUnsetParentFunction(parentPersister, inversePropertyIndex.Value);
            }

            // Get the element type from the collection in case it is a base class
            var type = (CollectionType)parentPersister.PropertyTypes[inversePropertyIndex.Value];
            if (!type.ReturnedClass.TryGetGenericType(typeof(ICollection<>), out var collectionType))
            {
                throw new NotSupportedException($"Mapped collection: {type.Role} is not supported.");
            }

            return (Action<object, object>) RemoveFromParentMethod.MakeGenericMethod(collectionType.GenericTypeArguments[0])
                .Invoke(null, new object[] {parentPersister, inversePropertyIndex.Value});
        }

        private static Action<object, object> CreateSetParentFunction(AbstractEntityPersister parentPersister, int parentPropertyIndex)
        {
            return (child, parent) => parentPersister.SetPropertyValue(parent, parentPropertyIndex, child);
        }

        private static Action<object, object> CreateUnsetParentFunction(AbstractEntityPersister parentPersister, int parentPropertyIndex)
        {
            return (child, parent) => parentPersister.SetPropertyValue(parent, parentPropertyIndex, null);
        }

        private static Action<object, object> CreateAddToParentFunction<TChild>(AbstractEntityPersister parentPersister, int parentPropertyIndex)
        {
            return (child, parent) =>
            {
                var collection = (ICollection<TChild>)parentPersister.GetPropertyValue(parent, parentPropertyIndex);
                collection.Add((TChild)child);
            };
        }

        private static Action<object, object> CreateRemoveFromParentFunction<TChild>(AbstractEntityPersister parentPersister, int parentPropertyIndex)
        {
            return (child, parent) =>
            {
                var collection = (ICollection<TChild>)parentPersister.GetPropertyValue(parent, parentPropertyIndex);
                collection.Remove((TChild)child);
            };
        }

        private static int? GetInversePropertyIndex(
            string[] columnNames,
            EntityType entityType,
            AbstractEntityPersister persister,
            AbstractEntityPersister relatedPersister,
            out bool isChildAssociation,
            out bool isOneToOne)
        {
            // many-to-one can be related to one-to-many or one-to-one
            // one-to-one can be related to many-to-one or one-to-one
            var propertyTypes = relatedPersister.PropertyTypes;
            for (var i = 0; i < propertyTypes.Length; i++)
            {
                var propertyType = propertyTypes[i];
                if (!propertyType.IsAssociationType)
                {
                    continue;
                }

                if (propertyType is CollectionType collectionType)
                {
                    var collectionPersister = (IQueryableCollection) collectionType.GetAssociatedJoinable(relatedPersister.Factory);
                    var referencedColumns = collectionType.GetReferencedColumns(relatedPersister.Factory);
                    if ((collectionPersister.ElementPersister == persister || collectionPersister.ElementPersister.IsSubclassEntityName(persister.EntityName))
                        && AreEqual(columnNames, referencedColumns, persister.Factory.Dialect))
                    {
                        isChildAssociation = true;
                        isOneToOne = false;
                        return i;
                    }

                    continue;
                }

                if (!(propertyType is EntityType relatedEntityType))
                {
                    continue;
                }

                if (entityType.IsOneToOne)
                {
                    if (entityType.RHSUniqueKeyPropertyName != null) // property-ref can only be mapped to many-to-one properly
                    {
                        if (entityType.RHSUniqueKeyPropertyName == relatedEntityType.PropertyName)
                        {
                            isChildAssociation = true;
                            isOneToOne = true;
                            return i;
                        }

                        continue;
                    }

                    // Search for one-to-one with the same entity name
                    if (relatedEntityType.IsOneToOne && relatedEntityType.Name == persister.EntityName)
                    {
                        isChildAssociation = persister.IdentifierGenerator is ForeignGenerator;
                        isOneToOne = true;
                        return i;
                    }
                }
                else if (relatedEntityType.IsOneToOne && 
                         !string.IsNullOrEmpty(relatedEntityType.RHSUniqueKeyPropertyName) &&
                         relatedEntityType.RHSUniqueKeyPropertyName == entityType.PropertyName) // many-to-one cannot be related another to many-to-one
                {
                    isChildAssociation = false;
                    isOneToOne = true;
                    return i;
                }
            }

            // many-to-one that does not have a one-to-many inverse property
            isChildAssociation = true;
            isOneToOne = false;
            return null;
        }

        private static bool AreEqual(string[] array, string[] toCompare, Dialect dialect)
        {
            if (array.Length != toCompare.Length)
            {
                return false;
            }

            for (var i = 0; i < array.Length; i++)
            {
                var name = array[i];
                var nameToCompare = toCompare[i];
                if (name == null || nameToCompare == null) // Formula
                {
                    if (name != nameToCompare)
                    {
                        return false;
                    }

                    continue;
                }

                if (dialect.UnQuote(name) != dialect.UnQuote(nameToCompare))
                {
                    return false;
                }
            }

            return true;
        }

        private static AutoGeneratedKeyType GetAutoGeneratedKeyType(AbstractEntityPersister persister)
        {
            if (persister.IdentifierType.IsComponentType)
            {
                return AutoGeneratedKeyType.None; // Client does not support temp keys for composite keys
            }

            if (!BreezeHelper.SupportsClientGenerator(persister.IdentifierType))
            {
                return AutoGeneratedKeyType.None;
            }

            switch (persister.IdentifierGenerator)
            {
                case Assigned _:
                case ForeignGenerator _:
                    return AutoGeneratedKeyType.None;
                default:
                    return AutoGeneratedKeyType.Identity;
            }
        }

        private Dictionary<string, Func<object, object>> GetManyToOneIdentifierProperties(AbstractEntityPersister persister)
        {
            if (!(persister.IdentifierType is ComponentType idComponent))
            {
                return null;
            }

            Dictionary<string, Func<object, object>> result = null;
            var types = idComponent.Subtypes;
            for (var i = 0; i < types.Length; i++)
            {
                if (types[i].IsAssociationType)
                {
                    result ??= new Dictionary<string, Func<object, object>>();
                    result.Add(idComponent.PropertyNames[i], CreateGetter(idComponent, i));
                }
            }

            return result;

            static Func<object, object> CreateGetter(ComponentType component, int index)
            {
                return entity => component.GetPropertyValue(entity, index);
            }
        }

        private void GetPkPropertyNames(AbstractEntityPersister persister,
            out string[] pkPropertyNames,
            out IType[] pkPropertyTypes,
            out Func<object, object>[] pkPropertyGetters,
            out bool isComposite)
        {
            if (persister.IdentifierType is ComponentType idComponent)
            {
                if (!idComponent.IsEmbedded)
                {
                    throw new NotSupportedException("Not embedded identifiers are not supported");
                }

                var dialect = persister.Factory.Dialect;
                var propertyNames = new List<string>();
                var propertyTypes = new List<IType>();
                var propertyGetters = new List<Func<object, object>>();
                var idPropertyNames = idComponent.PropertyNames;
                var idPropertyTypes = idComponent.Subtypes;
                var columnProperties = GetColumnProperties(persister, false);
                for (var i = 0; i < idPropertyTypes.Length; i++)
                {
                    var propertyGetter = GetPropertyValueFunction(idComponent, i);
                    if (idPropertyTypes[i] is EntityType entityType)
                    {
                        var elementPkPropertyPersister = GetEntityPersister(entityType.GetAssociatedEntityName(persister.Factory), true);
                        GetPkPropertyNames(elementPkPropertyPersister, out var elementPkPropertyNames, out var elementPkPropertyTypes, out var elementPkPropertyGetters, out var isElementPkComposite);
                        var pkPropertyColumnsNames = GetComponentPropertyColumnNames(persister.Factory, idComponent, i, persister.IdentifierColumnNames);
                        for (var j = 0; j < pkPropertyColumnsNames.Length; j++)
                        {
                            var column = pkPropertyColumnsNames[j];
                            if (column == null)
                            {
                                continue; // Formula
                            }

                            propertyNames.Add(columnProperties.TryGetValue(dialect.UnQuote(column), out var propertyName)
                                ? propertyName
                                : _syntheticPropertyNameConvention.GetName(idPropertyNames[i], elementPkPropertyNames[j]));
                            propertyTypes.Add(elementPkPropertyTypes[j]);
                            propertyGetters.Add(new SyntheticForeignKeyPropertyValueProvider(propertyGetter, elementPkPropertyGetters[j], isElementPkComposite).GetValue);
                        }
                    }
                    else
                    {
                        propertyNames.Add(idPropertyNames[i]);
                        propertyTypes.Add(idPropertyTypes[i]);
                        propertyGetters.Add(propertyGetter);
                    }
                }

                pkPropertyNames = propertyNames.ToArray();
                pkPropertyTypes = propertyTypes.ToArray();
                pkPropertyGetters = propertyGetters.ToArray();
                isComposite = true;
            }
            else
            {
                pkPropertyNames = new[] {persister.IdentifierPropertyName};
                pkPropertyTypes = new[] {persister.IdentifierType};
                pkPropertyGetters = new Func<object, object>[] {persister.GetIdentifier};
                isComposite = false;
            }
        }

        private static Dictionary<string, string> GetColumnProperties(AbstractEntityPersister persister, bool entityColumns)
        {
            var dialect = persister.Factory.Dialect;
            var result = new Dictionary<string, string>();
            FillColumnProperties(
                persister.PropertyNames,
                persister.PropertyTypes,
                entityColumns,
                persister.GetPropertyColumnNames,
                result,
                dialect);

            if (persister.IdentifierPropertyName != null)
            {
                // Breeze does not support entity association identifiers, ignore entityColumns value
                foreach (var columnName in persister.IdentifierColumnNames)
                {
                    if (columnName == null)
                    {
                        continue; // Formula
                    }

                    result.Add(dialect.UnQuote(columnName), persister.IdentifierPropertyName);
                }
            }
            else if (persister.IdentifierType is IAbstractComponentType componentType && componentType.IsEmbedded)
            {
                var allColumnNames = persister.IdentifierColumnNames;
                FillColumnProperties(
                    componentType.PropertyNames,
                    componentType.Subtypes,
                    entityColumns,
                    i => GetComponentPropertyColumnNames(persister.Factory, componentType, i, allColumnNames),
                    result,
                    dialect);
            }

            return result;
        }

        private static void FillColumnProperties(
            string[] propertyNames,
            IType[] propertyTypes,
            bool entityColumns,
            Func<int, string[]> getColumnNamesFunc,
            Dictionary<string, string> result,
            Dialect dialect)
        {
            for (var i = 0; i < propertyNames.Length; i++)
            {
                var propertyType = propertyTypes[i];
                if (propertyType.IsAssociationType)
                {
                    if (!entityColumns || !propertyType.IsEntityType)
                    {
                        continue;
                    }
                }
                else if (entityColumns)
                {
                    continue;
                }

                var columnNames = getColumnNamesFunc(i);
                foreach (var columnName in columnNames)
                {
                    if (columnName == null)
                    {
                        continue; // Formula
                    }

                    result.Add(dialect.UnQuote(columnName), propertyNames[i]);
                }
            }
        }

        private static string[] GetComponentPropertyColumnNames(
            ISessionFactoryImplementor sessionFactory,
            IAbstractComponentType componentType,
            int i,
            string[] allColumnNames)
        {
            var span = componentType.Subtypes[i].GetColumnSpan(sessionFactory);
            var columnNames = new string[span];
            var offset = componentType.Subtypes.Take(i).Select(o => o.GetColumnSpan(sessionFactory)).Sum();
            Array.Copy(allColumnNames, offset, columnNames, 0, span);

            return columnNames;
        }

        private static IEnumerable<Type> GetDerivedTypes(AbstractEntityPersister persister)
        {
            if (!persister.IsInherited)
            {
                yield break;
            }

            while (persister.EntityMetamodel.SuperclassType != null)
            {
                yield return persister.EntityMetamodel.SuperclassType;
                persister = (AbstractEntityPersister)persister.Factory.GetClassMetadata(persister.MappedSuperclass);
            }
        }

        private static IEnumerable<string> GetDerivedPropertyNames(AbstractEntityPersister persister)
        {
            if (!persister.IsInherited)
            {
                yield break;
            }

            var superMetadata = (AbstractEntityPersister)persister.Factory.GetClassMetadata(persister.MappedSuperclass);
            foreach (var propertyName in superMetadata.PropertyNames)
            {
                yield return propertyName;
            }

            if (superMetadata.IdentifierPropertyName != null)
            {
                yield return superMetadata.IdentifierPropertyName;
            }
        }

        private static Func<object, object> GetPropertyValueFunction(ComponentType componentType, int i)
        {
            return o => componentType.GetPropertyValue(o, i);
        }

        private static Func<object, object> GetPropertyValueFunction(AbstractEntityPersister persister, int i)
        {
            return o => persister.GetPropertyValue(o, i);
        }
    }
}
