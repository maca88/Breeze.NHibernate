using System;
using System.Collections.Generic;
using System.Linq;
using Breeze.NHibernate.Metadata;
using NHibernate.Persister.Entity;
using NHibernate.Type;

namespace Breeze.NHibernate
{
    /// <summary>
    /// Pre-calculated entity metadata mainly used for creating <see cref="BreezeMetadata"/> and saving entity changes.
    /// </summary>
    public class EntityMetadata : ModelMetadata
    {
        /// <summary>
        /// Constructs an instance of <see cref="EntityMetadata"/>.
        /// </summary>
        public EntityMetadata(
            AbstractEntityPersister entityPersister,
            Func<object> createInstance,
            IEntityBatchFetcher batchFetcher,
            Type type,
            Type baseType,
            AutoGeneratedKeyType autoGeneratedKeyType,
            string versionPropertyName,
            Type versionPropertyType,
            bool hasCompositeKey,
            IReadOnlyDictionary<string, SyntheticForeignKeyProperty> syntheticForeignKeyProperties,
            IReadOnlyCollection<Type> derivedTypes,
            IReadOnlyCollection<string> derivedPropertyNames,
            IReadOnlyList<string> identifierPropertyNames,
            IReadOnlyList<Func<object, object>> identifierPropertyGetters,
            IReadOnlyList<Type> identifierPropertyTypes,
            IReadOnlyList<DataType> identifierPropertyDataTypes,
            IReadOnlyList<int?> identifierPropertyTypeLengths,
            IReadOnlyCollection<string> foreignKeyPropertyNames,
            IReadOnlyDictionary<string, Association> associations,
            IReadOnlyDictionary<string, EntityAssociation> foreignKeyAssociations,
            IReadOnlyDictionary<string, Func<object, object>> manyToOneIdentifierProperties)
            : base(
                type,
                baseType,
                autoGeneratedKeyType,
                hasCompositeKey,
                syntheticForeignKeyProperties,
                derivedTypes,
                derivedPropertyNames,
                identifierPropertyNames,
                identifierPropertyGetters,
                identifierPropertyTypes,
                identifierPropertyDataTypes,
                identifierPropertyTypeLengths,
                foreignKeyPropertyNames,
                associations)
        {
            EntityPersister = entityPersister;
            CreateInstance = createInstance;
            BatchFetcher = batchFetcher;
            ForeignKeyAssociations = foreignKeyAssociations;
            VersionPropertyName = versionPropertyName;
            VersionPropertyType = versionPropertyType;
            ManyToOneIdentifierProperties = manyToOneIdentifierProperties;
            AllProperties = new HashSet<string>(
                identifierPropertyNames
                .Concat(manyToOneIdentifierProperties.Keys) // We have to add also many-to-one identifier names as identifierPropertyNames does not contain them
                .Concat(entityPersister.PropertyNames)
                .Concat(syntheticForeignKeyProperties.Select(o => o.Key)));
        }

        /// <summary>
        /// The entity persister.
        /// </summary>
        public AbstractEntityPersister EntityPersister { get; }

        /// <summary>
        /// The version property name.
        /// </summary>
        public string VersionPropertyName { get; }

        /// <summary>
        /// The version property type.
        /// </summary>
        public Type VersionPropertyType { get; }

        /// <summary>
        /// A function to created new entity instances.
        /// </summary>
        public Func<object> CreateInstance { get; }

        /// <summary>
        /// The entity batch fetcher.
        /// </summary>
        public IEntityBatchFetcher BatchFetcher { get; }

        /// <summary>
        /// A collection of all property names.
        /// </summary>
        public override IReadOnlyCollection<string> AllProperties { get; }

        /// <summary>
        /// A dictionary of foreign key associations.
        /// </summary>
        public IReadOnlyDictionary<string, EntityAssociation> ForeignKeyAssociations { get; }

        /// <summary>
        /// A dictionary of identifier properties that are mapped as key-many-to-one with their getters.
        /// </summary>
        public IReadOnlyDictionary<string, Func<object, object>> ManyToOneIdentifierProperties { get; }

        internal object GetIdentifier(object entity)
        {
            return HasCompositeKey
                ? GetIdentifierValues(entity)
                : EntityPersister.GetIdentifier(entity);
        }

        private object[] GetIdentifierValues(object entity)
        {
            var values = new object[IdentifierPropertyNames.Count];
            for (var i = 0; i < values.Length; i++)
            {
                values[i] = IdentifierPropertyGetters[i](entity);
            }

            return values;
        }
    }
}
